<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AR Sinusoid Surface with A-Frame</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    
    /* Non-fullscreen container */
    .scene-container {
      width: 100%;
      height: 80vh; /* 80% of viewport height */
      position: relative;
    }
    
    /* Control panel */
    .control-panel {
      width: 100%;
      height: 20vh; /* 20% of viewport height */
      background-color: #f0f0f0;
      padding: 10px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
    }
    
    .button-row {
      display: flex;
      justify-content: center;
      width: 100%;
      margin-bottom: 10px;
    }
    
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 15px;
      margin: 0 5px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    
    #debug {
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 5px;
      width: 90%;
      max-width: 400px;
      text-align: center;
      font-size: 12px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@1.3.0/dist/aframe-master.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  
  <script>
    // Custom component for the sinusoid surface
    AFRAME.registerComponent('sinusoid-surface', {
      schema: {
        amplitude: {type: 'number', default: 0.3},
        frequency: {type: 'number', default: 5},
        radius: {type: 'number', default: 1.0},
        circleCount: {type: 'number', default: 30},
        segmentsCount: {type: 'number', default: 30},
        color: {type: 'color', default: '#44ff44'}
      },
      
      init: function() {
        this.createSurface();
      },
      
      update: function() {
        // Remove existing mesh
        if (this.mesh) {
          this.el.removeObject3D('mesh');
        }
        
        // Create new surface with updated parameters
        this.createSurface();
      },
      
      createVertex: function(a, n, R, r, b) {
        const x = r * Math.cos(b);
        const y = r * Math.sin(b);
        const z = a * Math.cos(n * Math.PI * r / R);
        return new THREE.Vector3(x, y, z);
      },
      
      createSurface: function() {
        const data = this.data;
        const geometry = new THREE.BufferGeometry();
        
        const vertices = [];
        const indices = [];
        const radius = 1;
        
        const radiusStep = radius / data.circleCount;
        const segmentStep = (2 * Math.PI) / data.segmentsCount;
        const cols = data.segmentsCount + 1;
        
        // Create vertices
        for (let r_idx = 0; r_idx <= data.circleCount; r_idx++) {
          let r = r_idx * radiusStep;
          for (let b_idx = 0; b_idx <= data.segmentsCount; b_idx++) {
            let beta = b_idx * segmentStep;
            
            let vertex = this.createVertex(data.amplitude, data.frequency, data.radius, r, beta);
            vertices.push(vertex.x, vertex.y, vertex.z);
          }
        }
        
        // Create indices
        for (let r_idx = 0; r_idx < data.circleCount; r_idx++) {
          for (let b_idx = 0; b_idx < data.segmentsCount; b_idx++) {
            let v0 = r_idx * cols + b_idx;
            let v1 = v0 + 1;
            let v2 = v0 + cols;
            let v3 = v2 + 1;
            
            indices.push(v0, v1, v2);
            indices.push(v2, v1, v3);
          }
        }
        
        // Create the geometry
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();
        
        // Create the material
        const material = new THREE.MeshStandardMaterial({
          color: data.color,
          side: THREE.DoubleSide
        });
        
        // Create the mesh
        this.mesh = new THREE.Mesh(geometry, material);
        this.el.setObject3D('mesh', this.mesh);
      },
      
      remove: function() {
        if (this.mesh) {
          this.el.removeObject3D('mesh');
        }
      }
    });
    
    // Auto rotation component
    AFRAME.registerComponent('auto-rotate', {
      schema: {
        enabled: {type: 'boolean', default: true},
        speed: {type: 'number', default: 1}
      },
      
      tick: function(time, deltaTime) {
        if (this.data.enabled) {
          // Convert to seconds and apply rotation
          const rotationAmount = (deltaTime / 1000) * this.data.speed;
          this.el.object3D.rotation.y += rotationAmount;
        }
      }
    });
  </script>
</head>
<body>
  <div class="scene-container">
    <a-scene embedded arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;" renderer="antialias: true; logarithmicDepthBuffer: true; precision: mediump;">
      <!-- Define assets -->
      <a-assets>
        <img id="hiro" src="https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/images/HIRO.jpg" />
      </a-assets>
      
      <!-- Marker and models -->
      <a-marker preset="hiro">
        <!-- Container entity - position above marker -->
        <a-entity position="0 0.5 0">
          <!-- Transparent cube (static, not rotating) -->
          <a-box id="cube" 
                 color="#4287f5" 
                 opacity="0.2" 
                 scale="1.6 1.6 1.6" 
                 material="transparent: true; side: double; wireframe: true;">
          </a-box>
          
          <!-- Sinusoid surface (automatically rotating) -->
          <a-entity id="sinusoid"
                    sinusoid-surface="amplitude: 0.3; frequency: 5; radius: 1.0; color: #44ff44"
                    auto-rotate="enabled: true; speed: 0.5"
                    scale="0.7 0.7 0.7">
          </a-entity>
        </a-entity>
      </a-marker>
      
      <!-- Fixed camera with no controls -->
      <a-entity camera></a-entity>
    </a-scene>
  </div>
  
  <div class="control-panel">
    <div class="button-row">
      <button id="toggle-wireframe">Toggle Wireframe</button>
      <button id="change-color">Change Colors</button>
    </div>
    <div class="button-row">
      <button id="update-params">Update Parameters</button>
      <button id="toggle-rotation">Toggle Rotation</button>
    </div>
    <div id="debug">Amplitude: 0.3 | Frequency: 5 | Radius: 1.0</div>
  </div>
  
  <script>
    // Wait for everything to load
    document.addEventListener('DOMContentLoaded', function() {
      // Log info for debugging
      console.log('DOM loaded');
      
      // Access the elements
      const cubeElement = document.getElementById('cube');
      const sinusoidElement = document.getElementById('sinusoid');
      const debugElement = document.getElementById('debug');
      
      // Define color schemes
      const colorSchemes = [
        { surface: '#44ff44', cube: '#4287f5' },
        { surface: '#ff5555', cube: '#47d147' },
        { surface: '#f5a742', cube: '#42f5d1' },
        { surface: '#f54242', cube: '#f5f542' }
      ];
      let colorSchemeIndex = 0;
      
      // Button: Toggle Wireframe
      document.getElementById('toggle-wireframe').addEventListener('click', function() {
        const currentWireframe = cubeElement.getAttribute('material').wireframe;
        cubeElement.setAttribute('material', 'wireframe', !currentWireframe);
      });
      
      // Button: Change Colors
      document.getElementById('change-color').addEventListener('click', function() {
        colorSchemeIndex = (colorSchemeIndex + 1) % colorSchemes.length;
        const newColors = colorSchemes[colorSchemeIndex];
        
        cubeElement.setAttribute('color', newColors.cube);
        sinusoidElement.setAttribute('sinusoid-surface', 'color', newColors.surface);
      });
      
      // Button: Update Parameters
      document.getElementById('update-params').addEventListener('click', function() {
        const newAmplitude = 0.1 + Math.random() * 0.4; // 0.1 to 0.5
        const newFrequency = 2 + Math.floor(Math.random() * 4); // 2 to 5
        
        sinusoidElement.setAttribute('sinusoid-surface', {
          amplitude: newAmplitude,
          frequency: newFrequency
        });
        
        // Update debug information
        debugElement.textContent = `Amplitude: ${newAmplitude.toFixed(2)} | Frequency: ${newFrequency} | Radius: 1.0`;
      });
      
      // Button: Toggle Rotation
      document.getElementById('toggle-rotation').addEventListener('click', function() {
        const currentRotation = sinusoidElement.getAttribute('auto-rotate').enabled;
        sinusoidElement.setAttribute('auto-rotate', 'enabled', !currentRotation);
        
        // Change button color based on state
        this.style.backgroundColor = !currentRotation ? '#4CAF50' : '#ff7f00';
      });
      
      // Log when marker is found or lost
      const marker = document.querySelector('a-marker');
      marker.addEventListener('markerFound', function() {
        console.log('Marker found!');
        debugElement.style.backgroundColor = '#e6ffe6'; // Light green
      });
      
      marker.addEventListener('markerLost', function() {
        console.log('Marker lost');
        debugElement.style.backgroundColor = '#ffe6e6'; // Light red
      });
    });
  </script>
</body>
</html>